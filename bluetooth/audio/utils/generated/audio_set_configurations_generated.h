// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AUDIOSETCONFIGURATIONS_AIDL_ANDROID_HARDWARE_BLUETOOTH_AUDIO_LE_AUDIO_H_
#define FLATBUFFERS_GENERATED_AUDIOSETCONFIGURATIONS_AIDL_ANDROID_HARDWARE_BLUETOOTH_AUDIO_LE_AUDIO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

namespace aidl {
namespace android {
namespace hardware {
namespace bluetooth {
namespace audio {
namespace le_audio {

struct CompoundValue;
struct CompoundValueBuilder;

struct CodecSpecificConfiguration;
struct CodecSpecificConfigurationBuilder;

struct CodecId;

struct AudioSetSubConfiguration;
struct AudioSetSubConfigurationBuilder;

struct CodecConfiguration;
struct CodecConfigurationBuilder;

struct QosConfiguration;
struct QosConfigurationBuilder;

struct AudioSetConfiguration;
struct AudioSetConfigurationBuilder;

struct AudioSetConfigurations;
struct AudioSetConfigurationsBuilder;

enum CodecSpecificLtvGenericTypes : int8_t {
  CodecSpecificLtvGenericTypes_SUPPORTED_SAMPLING_FREQUENCY = 1,
  CodecSpecificLtvGenericTypes_SUPPORTED_FRAME_DURATION = 2,
  CodecSpecificLtvGenericTypes_SUPPORTED_AUDIO_CHANNEL_ALLOCATION = 3,
  CodecSpecificLtvGenericTypes_SUPPORTED_OCTETS_PER_CODEC_FRAME = 4,
  CodecSpecificLtvGenericTypes_SUPPORTED_CODEC_FRAME_BLOCKS_PER_SDU = 5,
  CodecSpecificLtvGenericTypes_MIN = CodecSpecificLtvGenericTypes_SUPPORTED_SAMPLING_FREQUENCY,
  CodecSpecificLtvGenericTypes_MAX = CodecSpecificLtvGenericTypes_SUPPORTED_CODEC_FRAME_BLOCKS_PER_SDU
};

inline const CodecSpecificLtvGenericTypes (&EnumValuesCodecSpecificLtvGenericTypes())[5] {
  static const CodecSpecificLtvGenericTypes values[] = {
    CodecSpecificLtvGenericTypes_SUPPORTED_SAMPLING_FREQUENCY,
    CodecSpecificLtvGenericTypes_SUPPORTED_FRAME_DURATION,
    CodecSpecificLtvGenericTypes_SUPPORTED_AUDIO_CHANNEL_ALLOCATION,
    CodecSpecificLtvGenericTypes_SUPPORTED_OCTETS_PER_CODEC_FRAME,
    CodecSpecificLtvGenericTypes_SUPPORTED_CODEC_FRAME_BLOCKS_PER_SDU
  };
  return values;
}

inline const char * const *EnumNamesCodecSpecificLtvGenericTypes() {
  static const char * const names[6] = {
    "SUPPORTED_SAMPLING_FREQUENCY",
    "SUPPORTED_FRAME_DURATION",
    "SUPPORTED_AUDIO_CHANNEL_ALLOCATION",
    "SUPPORTED_OCTETS_PER_CODEC_FRAME",
    "SUPPORTED_CODEC_FRAME_BLOCKS_PER_SDU",
    nullptr
  };
  return names;
}

inline const char *EnumNameCodecSpecificLtvGenericTypes(CodecSpecificLtvGenericTypes e) {
  if (flatbuffers::IsOutRange(e, CodecSpecificLtvGenericTypes_SUPPORTED_SAMPLING_FREQUENCY, CodecSpecificLtvGenericTypes_SUPPORTED_CODEC_FRAME_BLOCKS_PER_SDU)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CodecSpecificLtvGenericTypes_SUPPORTED_SAMPLING_FREQUENCY);
  return EnumNamesCodecSpecificLtvGenericTypes()[index];
}

enum AudioSetConfigurationStrategy : int8_t {
  AudioSetConfigurationStrategy_MONO_ONE_CIS_PER_DEVICE = 0,
  AudioSetConfigurationStrategy_STEREO_TWO_CISES_PER_DEVICE = 1,
  AudioSetConfigurationStrategy_STEREO_ONE_CIS_PER_DEVICE = 2,
  AudioSetConfigurationStrategy_MIN = AudioSetConfigurationStrategy_MONO_ONE_CIS_PER_DEVICE,
  AudioSetConfigurationStrategy_MAX = AudioSetConfigurationStrategy_STEREO_ONE_CIS_PER_DEVICE
};

inline const AudioSetConfigurationStrategy (&EnumValuesAudioSetConfigurationStrategy())[3] {
  static const AudioSetConfigurationStrategy values[] = {
    AudioSetConfigurationStrategy_MONO_ONE_CIS_PER_DEVICE,
    AudioSetConfigurationStrategy_STEREO_TWO_CISES_PER_DEVICE,
    AudioSetConfigurationStrategy_STEREO_ONE_CIS_PER_DEVICE
  };
  return values;
}

inline const char * const *EnumNamesAudioSetConfigurationStrategy() {
  static const char * const names[4] = {
    "MONO_ONE_CIS_PER_DEVICE",
    "STEREO_TWO_CISES_PER_DEVICE",
    "STEREO_ONE_CIS_PER_DEVICE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAudioSetConfigurationStrategy(AudioSetConfigurationStrategy e) {
  if (flatbuffers::IsOutRange(e, AudioSetConfigurationStrategy_MONO_ONE_CIS_PER_DEVICE, AudioSetConfigurationStrategy_STEREO_ONE_CIS_PER_DEVICE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAudioSetConfigurationStrategy()[index];
}

enum AudioSetConfigurationDirection : int8_t {
  AudioSetConfigurationDirection_SINK = 1,
  AudioSetConfigurationDirection_SOURCE = 2,
  AudioSetConfigurationDirection_MIN = AudioSetConfigurationDirection_SINK,
  AudioSetConfigurationDirection_MAX = AudioSetConfigurationDirection_SOURCE
};

inline const AudioSetConfigurationDirection (&EnumValuesAudioSetConfigurationDirection())[2] {
  static const AudioSetConfigurationDirection values[] = {
    AudioSetConfigurationDirection_SINK,
    AudioSetConfigurationDirection_SOURCE
  };
  return values;
}

inline const char * const *EnumNamesAudioSetConfigurationDirection() {
  static const char * const names[3] = {
    "SINK",
    "SOURCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAudioSetConfigurationDirection(AudioSetConfigurationDirection e) {
  if (flatbuffers::IsOutRange(e, AudioSetConfigurationDirection_SINK, AudioSetConfigurationDirection_SOURCE)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AudioSetConfigurationDirection_SINK);
  return EnumNamesAudioSetConfigurationDirection()[index];
}

enum AudioSetConfigurationTargetLatency : int8_t {
  AudioSetConfigurationTargetLatency_LOW = 1,
  AudioSetConfigurationTargetLatency_BALANCED_RELIABILITY = 2,
  AudioSetConfigurationTargetLatency_HIGH_RELIABILITY = 3,
  AudioSetConfigurationTargetLatency_MIN = AudioSetConfigurationTargetLatency_LOW,
  AudioSetConfigurationTargetLatency_MAX = AudioSetConfigurationTargetLatency_HIGH_RELIABILITY
};

inline const AudioSetConfigurationTargetLatency (&EnumValuesAudioSetConfigurationTargetLatency())[3] {
  static const AudioSetConfigurationTargetLatency values[] = {
    AudioSetConfigurationTargetLatency_LOW,
    AudioSetConfigurationTargetLatency_BALANCED_RELIABILITY,
    AudioSetConfigurationTargetLatency_HIGH_RELIABILITY
  };
  return values;
}

inline const char * const *EnumNamesAudioSetConfigurationTargetLatency() {
  static const char * const names[4] = {
    "LOW",
    "BALANCED_RELIABILITY",
    "HIGH_RELIABILITY",
    nullptr
  };
  return names;
}

inline const char *EnumNameAudioSetConfigurationTargetLatency(AudioSetConfigurationTargetLatency e) {
  if (flatbuffers::IsOutRange(e, AudioSetConfigurationTargetLatency_LOW, AudioSetConfigurationTargetLatency_HIGH_RELIABILITY)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AudioSetConfigurationTargetLatency_LOW);
  return EnumNamesAudioSetConfigurationTargetLatency()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) CodecId FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t coding_format_;
  int8_t padding0__;
  uint16_t vendor_company_id_;
  uint16_t vendor_codec_id_;

 public:
  CodecId()
      : coding_format_(0),
        padding0__(0),
        vendor_company_id_(0),
        vendor_codec_id_(0) {
    (void)padding0__;
  }
  CodecId(uint8_t _coding_format, uint16_t _vendor_company_id, uint16_t _vendor_codec_id)
      : coding_format_(flatbuffers::EndianScalar(_coding_format)),
        padding0__(0),
        vendor_company_id_(flatbuffers::EndianScalar(_vendor_company_id)),
        vendor_codec_id_(flatbuffers::EndianScalar(_vendor_codec_id)) {
    (void)padding0__;
  }
  uint8_t coding_format() const {
    return flatbuffers::EndianScalar(coding_format_);
  }
  uint16_t vendor_company_id() const {
    return flatbuffers::EndianScalar(vendor_company_id_);
  }
  uint16_t vendor_codec_id() const {
    return flatbuffers::EndianScalar(vendor_codec_id_);
  }
};
FLATBUFFERS_STRUCT_END(CodecId, 6);

/// Note: Holds either a single value (when `value_width == 0`) or multiple
///       values if `value.length()` is no-remainder divisible by the non-zero
///       `value_width`.
/// Note: Consider extending it with `flags` field, to hold additional info like
///       IsBitfield, IsRange, etc. if we need these type-specific validations.
struct CompoundValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompoundValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_VALUE_WIDTH = 6
  };
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  uint8_t value_width() const {
    return GetField<uint8_t>(VT_VALUE_WIDTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_WIDTH, 1) &&
           verifier.EndTable();
  }
};

struct CompoundValueBuilder {
  typedef CompoundValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(CompoundValue::VT_VALUE, value);
  }
  void add_value_width(uint8_t value_width) {
    fbb_.AddElement<uint8_t>(CompoundValue::VT_VALUE_WIDTH, value_width, 0);
  }
  explicit CompoundValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompoundValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompoundValue>(end);
    fbb_.Required(o, CompoundValue::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<CompoundValue> CreateCompoundValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0,
    uint8_t value_width = 0) {
  CompoundValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_width(value_width);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompoundValue> CreateCompoundValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr,
    uint8_t value_width = 0) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateCompoundValue(
      _fbb,
      value__,
      value_width);
}

struct CodecSpecificConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CodecSpecificConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_COMPOUND_VALUE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool KeyCompareLessThan(const CodecSpecificConfiguration *o) const {
    return type() < o->type();
  }
  int KeyCompareWithValue(uint8_t _type) const {
    return static_cast<int>(type() > _type) - static_cast<int>(type() < _type);
  }
  const aidl::android::hardware::bluetooth::audio::le_audio::CompoundValue *compound_value() const {
    return GetPointer<const aidl::android::hardware::bluetooth::audio::le_audio::CompoundValue *>(VT_COMPOUND_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPOUND_VALUE) &&
           verifier.VerifyTable(compound_value()) &&
           verifier.EndTable();
  }
};

struct CodecSpecificConfigurationBuilder {
  typedef CodecSpecificConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CodecSpecificConfiguration::VT_NAME, name);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(CodecSpecificConfiguration::VT_TYPE, type, 0);
  }
  void add_compound_value(flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CompoundValue> compound_value) {
    fbb_.AddOffset(CodecSpecificConfiguration::VT_COMPOUND_VALUE, compound_value);
  }
  explicit CodecSpecificConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CodecSpecificConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CodecSpecificConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<CodecSpecificConfiguration> CreateCodecSpecificConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t type = 0,
    flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CompoundValue> compound_value = 0) {
  CodecSpecificConfigurationBuilder builder_(_fbb);
  builder_.add_compound_value(compound_value);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CodecSpecificConfiguration> CreateCodecSpecificConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint8_t type = 0,
    flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CompoundValue> compound_value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateCodecSpecificConfiguration(
      _fbb,
      name__,
      type,
      compound_value);
}

struct AudioSetSubConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioSetSubConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICE_CNT = 4,
    VT_ASE_CNT = 6,
    VT_DIRECTION = 8,
    VT_CONFIGURATION_STRATEGY = 10,
    VT_CODEC_ID = 12,
    VT_CODEC_CONFIGURATION = 14
  };
  uint8_t device_cnt() const {
    return GetField<uint8_t>(VT_DEVICE_CNT, 0);
  }
  uint8_t ase_cnt() const {
    return GetField<uint8_t>(VT_ASE_CNT, 0);
  }
  aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection direction() const {
    return static_cast<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection>(GetField<int8_t>(VT_DIRECTION, 1));
  }
  aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy configuration_strategy() const {
    return static_cast<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy>(GetField<int8_t>(VT_CONFIGURATION_STRATEGY, 0));
  }
  const aidl::android::hardware::bluetooth::audio::le_audio::CodecId *codec_id() const {
    return GetStruct<const aidl::android::hardware::bluetooth::audio::le_audio::CodecId *>(VT_CODEC_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecSpecificConfiguration>> *codec_configuration() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecSpecificConfiguration>> *>(VT_CODEC_CONFIGURATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DEVICE_CNT, 1) &&
           VerifyField<uint8_t>(verifier, VT_ASE_CNT, 1) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION, 1) &&
           VerifyField<int8_t>(verifier, VT_CONFIGURATION_STRATEGY, 1) &&
           VerifyFieldRequired<aidl::android::hardware::bluetooth::audio::le_audio::CodecId>(verifier, VT_CODEC_ID, 2) &&
           VerifyOffsetRequired(verifier, VT_CODEC_CONFIGURATION) &&
           verifier.VerifyVector(codec_configuration()) &&
           verifier.VerifyVectorOfTables(codec_configuration()) &&
           verifier.EndTable();
  }
};

struct AudioSetSubConfigurationBuilder {
  typedef AudioSetSubConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_device_cnt(uint8_t device_cnt) {
    fbb_.AddElement<uint8_t>(AudioSetSubConfiguration::VT_DEVICE_CNT, device_cnt, 0);
  }
  void add_ase_cnt(uint8_t ase_cnt) {
    fbb_.AddElement<uint8_t>(AudioSetSubConfiguration::VT_ASE_CNT, ase_cnt, 0);
  }
  void add_direction(aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection direction) {
    fbb_.AddElement<int8_t>(AudioSetSubConfiguration::VT_DIRECTION, static_cast<int8_t>(direction), 1);
  }
  void add_configuration_strategy(aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy configuration_strategy) {
    fbb_.AddElement<int8_t>(AudioSetSubConfiguration::VT_CONFIGURATION_STRATEGY, static_cast<int8_t>(configuration_strategy), 0);
  }
  void add_codec_id(const aidl::android::hardware::bluetooth::audio::le_audio::CodecId *codec_id) {
    fbb_.AddStruct(AudioSetSubConfiguration::VT_CODEC_ID, codec_id);
  }
  void add_codec_configuration(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecSpecificConfiguration>>> codec_configuration) {
    fbb_.AddOffset(AudioSetSubConfiguration::VT_CODEC_CONFIGURATION, codec_configuration);
  }
  explicit AudioSetSubConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioSetSubConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSetSubConfiguration>(end);
    fbb_.Required(o, AudioSetSubConfiguration::VT_CODEC_ID);
    fbb_.Required(o, AudioSetSubConfiguration::VT_CODEC_CONFIGURATION);
    return o;
  }
};

inline flatbuffers::Offset<AudioSetSubConfiguration> CreateAudioSetSubConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t device_cnt = 0,
    uint8_t ase_cnt = 0,
    aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection direction = aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection_SINK,
    aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy configuration_strategy = aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy_MONO_ONE_CIS_PER_DEVICE,
    const aidl::android::hardware::bluetooth::audio::le_audio::CodecId *codec_id = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecSpecificConfiguration>>> codec_configuration = 0) {
  AudioSetSubConfigurationBuilder builder_(_fbb);
  builder_.add_codec_configuration(codec_configuration);
  builder_.add_codec_id(codec_id);
  builder_.add_configuration_strategy(configuration_strategy);
  builder_.add_direction(direction);
  builder_.add_ase_cnt(ase_cnt);
  builder_.add_device_cnt(device_cnt);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioSetSubConfiguration> CreateAudioSetSubConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t device_cnt = 0,
    uint8_t ase_cnt = 0,
    aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection direction = aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationDirection_SINK,
    aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy configuration_strategy = aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationStrategy_MONO_ONE_CIS_PER_DEVICE,
    const aidl::android::hardware::bluetooth::audio::le_audio::CodecId *codec_id = nullptr,
    std::vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecSpecificConfiguration>> *codec_configuration = nullptr) {
  auto codec_configuration__ = codec_configuration ? _fbb.CreateVectorOfSortedTables<aidl::android::hardware::bluetooth::audio::le_audio::CodecSpecificConfiguration>(codec_configuration) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateAudioSetSubConfiguration(
      _fbb,
      device_cnt,
      ase_cnt,
      direction,
      configuration_strategy,
      codec_id,
      codec_configuration__);
}

struct CodecConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CodecConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SUBCONFIGURATIONS = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const CodecConfiguration *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetSubConfiguration>> *subconfigurations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetSubConfiguration>> *>(VT_SUBCONFIGURATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_SUBCONFIGURATIONS) &&
           verifier.VerifyVector(subconfigurations()) &&
           verifier.VerifyVectorOfTables(subconfigurations()) &&
           verifier.EndTable();
  }
};

struct CodecConfigurationBuilder {
  typedef CodecConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CodecConfiguration::VT_NAME, name);
  }
  void add_subconfigurations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetSubConfiguration>>> subconfigurations) {
    fbb_.AddOffset(CodecConfiguration::VT_SUBCONFIGURATIONS, subconfigurations);
  }
  explicit CodecConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CodecConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CodecConfiguration>(end);
    fbb_.Required(o, CodecConfiguration::VT_NAME);
    fbb_.Required(o, CodecConfiguration::VT_SUBCONFIGURATIONS);
    return o;
  }
};

inline flatbuffers::Offset<CodecConfiguration> CreateCodecConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetSubConfiguration>>> subconfigurations = 0) {
  CodecConfigurationBuilder builder_(_fbb);
  builder_.add_subconfigurations(subconfigurations);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CodecConfiguration> CreateCodecConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetSubConfiguration>> *subconfigurations = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto subconfigurations__ = subconfigurations ? _fbb.CreateVector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetSubConfiguration>>(*subconfigurations) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateCodecConfiguration(
      _fbb,
      name__,
      subconfigurations__);
}

struct QosConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QosConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TARGET_LATENCY = 6,
    VT_RETRANSMISSION_NUMBER = 8,
    VT_MAX_TRANSPORT_LATENCY = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const QosConfiguration *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency target_latency() const {
    return static_cast<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency>(GetField<int8_t>(VT_TARGET_LATENCY, 2));
  }
  uint8_t retransmission_number() const {
    return GetField<uint8_t>(VT_RETRANSMISSION_NUMBER, 0);
  }
  uint16_t max_transport_latency() const {
    return GetField<uint16_t>(VT_MAX_TRANSPORT_LATENCY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TARGET_LATENCY, 1) &&
           VerifyField<uint8_t>(verifier, VT_RETRANSMISSION_NUMBER, 1) &&
           VerifyField<uint16_t>(verifier, VT_MAX_TRANSPORT_LATENCY, 2) &&
           verifier.EndTable();
  }
};

struct QosConfigurationBuilder {
  typedef QosConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(QosConfiguration::VT_NAME, name);
  }
  void add_target_latency(aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency target_latency) {
    fbb_.AddElement<int8_t>(QosConfiguration::VT_TARGET_LATENCY, static_cast<int8_t>(target_latency), 2);
  }
  void add_retransmission_number(uint8_t retransmission_number) {
    fbb_.AddElement<uint8_t>(QosConfiguration::VT_RETRANSMISSION_NUMBER, retransmission_number, 0);
  }
  void add_max_transport_latency(uint16_t max_transport_latency) {
    fbb_.AddElement<uint16_t>(QosConfiguration::VT_MAX_TRANSPORT_LATENCY, max_transport_latency, 0);
  }
  explicit QosConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QosConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QosConfiguration>(end);
    fbb_.Required(o, QosConfiguration::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<QosConfiguration> CreateQosConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency target_latency = aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency_BALANCED_RELIABILITY,
    uint8_t retransmission_number = 0,
    uint16_t max_transport_latency = 0) {
  QosConfigurationBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_max_transport_latency(max_transport_latency);
  builder_.add_retransmission_number(retransmission_number);
  builder_.add_target_latency(target_latency);
  return builder_.Finish();
}

inline flatbuffers::Offset<QosConfiguration> CreateQosConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency target_latency = aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurationTargetLatency_BALANCED_RELIABILITY,
    uint8_t retransmission_number = 0,
    uint16_t max_transport_latency = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateQosConfiguration(
      _fbb,
      name__,
      target_latency,
      retransmission_number,
      max_transport_latency);
}

/// Each set configration can contain multiple logical subconfigurations, which
/// all must be configurable with the current set of audio devices. For example,
/// one can define multiple output stream configurations with different
/// qualities, or assign different configurations to each stream direction.
struct AudioSetConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioSetConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CODEC_CONFIG_NAME = 6,
    VT_QOS_CONFIG_NAME = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const AudioSetConfiguration *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  const flatbuffers::String *codec_config_name() const {
    return GetPointer<const flatbuffers::String *>(VT_CODEC_CONFIG_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *qos_config_name() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_QOS_CONFIG_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CODEC_CONFIG_NAME) &&
           verifier.VerifyString(codec_config_name()) &&
           VerifyOffsetRequired(verifier, VT_QOS_CONFIG_NAME) &&
           verifier.VerifyVector(qos_config_name()) &&
           verifier.VerifyVectorOfStrings(qos_config_name()) &&
           verifier.EndTable();
  }
};

struct AudioSetConfigurationBuilder {
  typedef AudioSetConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AudioSetConfiguration::VT_NAME, name);
  }
  void add_codec_config_name(flatbuffers::Offset<flatbuffers::String> codec_config_name) {
    fbb_.AddOffset(AudioSetConfiguration::VT_CODEC_CONFIG_NAME, codec_config_name);
  }
  void add_qos_config_name(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> qos_config_name) {
    fbb_.AddOffset(AudioSetConfiguration::VT_QOS_CONFIG_NAME, qos_config_name);
  }
  explicit AudioSetConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioSetConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSetConfiguration>(end);
    fbb_.Required(o, AudioSetConfiguration::VT_NAME);
    fbb_.Required(o, AudioSetConfiguration::VT_CODEC_CONFIG_NAME);
    fbb_.Required(o, AudioSetConfiguration::VT_QOS_CONFIG_NAME);
    return o;
  }
};

inline flatbuffers::Offset<AudioSetConfiguration> CreateAudioSetConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> codec_config_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> qos_config_name = 0) {
  AudioSetConfigurationBuilder builder_(_fbb);
  builder_.add_qos_config_name(qos_config_name);
  builder_.add_codec_config_name(codec_config_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioSetConfiguration> CreateAudioSetConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *codec_config_name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *qos_config_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto codec_config_name__ = codec_config_name ? _fbb.CreateString(codec_config_name) : 0;
  auto qos_config_name__ = qos_config_name ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*qos_config_name) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateAudioSetConfiguration(
      _fbb,
      name__,
      codec_config_name__,
      qos_config_name__);
}

struct AudioSetConfigurations FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioSetConfigurationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT__COMMENTS_ = 4,
    VT_CONFIGURATIONS = 6,
    VT_CODEC_CONFIGURATIONS = 8,
    VT_QOS_CONFIGURATIONS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *_comments_() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT__COMMENTS_);
  }
  const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfiguration>> *configurations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfiguration>> *>(VT_CONFIGURATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecConfiguration>> *codec_configurations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecConfiguration>> *>(VT_CODEC_CONFIGURATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::QosConfiguration>> *qos_configurations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::QosConfiguration>> *>(VT_QOS_CONFIGURATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT__COMMENTS_) &&
           verifier.VerifyVector(_comments_()) &&
           verifier.VerifyVectorOfStrings(_comments_()) &&
           VerifyOffsetRequired(verifier, VT_CONFIGURATIONS) &&
           verifier.VerifyVector(configurations()) &&
           verifier.VerifyVectorOfTables(configurations()) &&
           VerifyOffsetRequired(verifier, VT_CODEC_CONFIGURATIONS) &&
           verifier.VerifyVector(codec_configurations()) &&
           verifier.VerifyVectorOfTables(codec_configurations()) &&
           VerifyOffsetRequired(verifier, VT_QOS_CONFIGURATIONS) &&
           verifier.VerifyVector(qos_configurations()) &&
           verifier.VerifyVectorOfTables(qos_configurations()) &&
           verifier.EndTable();
  }
};

struct AudioSetConfigurationsBuilder {
  typedef AudioSetConfigurations Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__comments_(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> _comments_) {
    fbb_.AddOffset(AudioSetConfigurations::VT__COMMENTS_, _comments_);
  }
  void add_configurations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfiguration>>> configurations) {
    fbb_.AddOffset(AudioSetConfigurations::VT_CONFIGURATIONS, configurations);
  }
  void add_codec_configurations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecConfiguration>>> codec_configurations) {
    fbb_.AddOffset(AudioSetConfigurations::VT_CODEC_CONFIGURATIONS, codec_configurations);
  }
  void add_qos_configurations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::QosConfiguration>>> qos_configurations) {
    fbb_.AddOffset(AudioSetConfigurations::VT_QOS_CONFIGURATIONS, qos_configurations);
  }
  explicit AudioSetConfigurationsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioSetConfigurations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSetConfigurations>(end);
    fbb_.Required(o, AudioSetConfigurations::VT_CONFIGURATIONS);
    fbb_.Required(o, AudioSetConfigurations::VT_CODEC_CONFIGURATIONS);
    fbb_.Required(o, AudioSetConfigurations::VT_QOS_CONFIGURATIONS);
    return o;
  }
};

inline flatbuffers::Offset<AudioSetConfigurations> CreateAudioSetConfigurations(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> _comments_ = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfiguration>>> configurations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecConfiguration>>> codec_configurations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::QosConfiguration>>> qos_configurations = 0) {
  AudioSetConfigurationsBuilder builder_(_fbb);
  builder_.add_qos_configurations(qos_configurations);
  builder_.add_codec_configurations(codec_configurations);
  builder_.add_configurations(configurations);
  builder_.add__comments_(_comments_);
  return builder_.Finish();
}

inline flatbuffers::Offset<AudioSetConfigurations> CreateAudioSetConfigurationsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *_comments_ = nullptr,
    std::vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfiguration>> *configurations = nullptr,
    std::vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::CodecConfiguration>> *codec_configurations = nullptr,
    std::vector<flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::QosConfiguration>> *qos_configurations = nullptr) {
  auto _comments___ = _comments_ ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*_comments_) : 0;
  auto configurations__ = configurations ? _fbb.CreateVectorOfSortedTables<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfiguration>(configurations) : 0;
  auto codec_configurations__ = codec_configurations ? _fbb.CreateVectorOfSortedTables<aidl::android::hardware::bluetooth::audio::le_audio::CodecConfiguration>(codec_configurations) : 0;
  auto qos_configurations__ = qos_configurations ? _fbb.CreateVectorOfSortedTables<aidl::android::hardware::bluetooth::audio::le_audio::QosConfiguration>(qos_configurations) : 0;
  return aidl::android::hardware::bluetooth::audio::le_audio::CreateAudioSetConfigurations(
      _fbb,
      _comments___,
      configurations__,
      codec_configurations__,
      qos_configurations__);
}

inline const aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations *GetAudioSetConfigurations(const void *buf) {
  return flatbuffers::GetRoot<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations>(buf);
}

inline const aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations *GetSizePrefixedAudioSetConfigurations(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations>(buf);
}

inline bool VerifyAudioSetConfigurationsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations>(nullptr);
}

inline bool VerifySizePrefixedAudioSetConfigurationsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations>(nullptr);
}

inline void FinishAudioSetConfigurationsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAudioSetConfigurationsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<aidl::android::hardware::bluetooth::audio::le_audio::AudioSetConfigurations> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace le_audio
}  // namespace audio
}  // namespace bluetooth
}  // namespace hardware
}  // namespace android
}  // namespace aidl

#endif  // FLATBUFFERS_GENERATED_AUDIOSETCONFIGURATIONS_AIDL_ANDROID_HARDWARE_BLUETOOTH_AUDIO_LE_AUDIO_H_
